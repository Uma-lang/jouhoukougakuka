<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数値計算の例</title>
    <!-- MathJax CDN -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="./else/style.css"> <!-- "css" フォルダ内のstyle.cssを参照 -->
</head>

<body>
    <h1>Q1.桁落ちとは何か？</h1>
    <h3>非常に近い数値の引き算を含む計算において、有効数字が大幅に減少してしまうこと。</h3>
    <h1>Q2.二次方程式の解の公式を桁落ちが少なくなる形に変形せよ</h1>
    <h3>2次方程式の解の公式を用いて解を求める際に、0に近い解がある時も桁落ちが生じることがある。</h3>
    <p>
        2次方程式 \( ax^2 + bx + c = 0 \) の解の公式は、
    </p>
    <p>
        \( x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \) (3.4.1)
    </p>
    <p>
        であるが、\( b > 0 \), \( b^2 \gg 4ac \) のときには \( -b + \sqrt{b^2 - 4ac} \) は近い値の引き算になる。（\( \gg \) は非常に大きいの意味）
    </p>
    <p>
        また、\( b < 0 \), \( b^2 \gg 4ac \) のときは、\( -b - \sqrt{b^2 - 4ac} \) は近い値の引き算になる。
        したがって \( b^2 \gg 4ac \) のときは、解のひとつで桁落ちが生じる可能性がある。
    </p>
    <p>
        これを防ぐには、桁落ちを生じない一つの解を求めたのち、解と係数の関係を用いてもう一つの解を求める。解と係数の関係にはいくつかあるが、
        ここで用いるのは、2つの解を \( x_1 \), \( x_2 \) とするとき、\( x_1 x_2 = \frac{c}{a} \) となる関係である。すなわち、次のようにすればよい。
    </p>
    <p>
        \( 
        x_1 =
        \begin{cases}
        \frac{-b - \sqrt{b^2 - 4ac}}{2a} & (b \geq 0) \\
        \frac{-b + \sqrt{b^2 - 4ac}}{2a} & (b < 0)
        \end{cases}
        \) (3.4.2)
    </p>
    <p>
        \( x_2 = \frac{c}{a x_1} \) (3.4.3)
    </p>
    <p>
        上記のようにすれば、\( x_1 \) の分子は同符号の加算になるので桁落ちは生じない。
    </p>
    <p>
        テキストにはない式で桁落ちを少なくする式に変形する問題もでる。
    </p>
    <h1>Q3.\( \sum_{n=1}^N = \frac{1}{n^2}\)を計算する時精度がいい形は？</h1>
    <h2>3.5 積残し</h2>
    <p>
        大きさが非常に異なる数値の足し算をするとき、小さい項が無視されることがある。例えば、有効桁5桁の計算では、
    </p>
    <p>
        \( 12345 + 0.12345 = 12345 \)
    </p>
    <p>
        となってしまい、\( 0.12345 \) の項が無視されてしまう。この現象を<strong>積残し</strong>または<strong>情報落ち</strong>と呼ぶ。
    </p>

    <h3>例 3.7</h3>
    <p>
        \( \sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6} \)
    </p>
    <p>
        となる。この左辺を計算する。  
        \( \sum_{n=1}^\infty \frac{1}{n^2} \) を数値計算でもとめることはできないので、大きい \( N = 100000 \) などに対して
        \( \sum_{n=1}^N \frac{1}{n^2} \) を計算する。
    </p>
    <p>
        \( N \) を大きくすればするほど、上記の和は \( \frac{\pi^2}{6} \) に近づくはずである。
        しかし、この和を計算するとき
    </p>
    <p>
        \( 1 + \frac{1}{2^2} + \frac{1}{3^2} + \dots \)
    </p>
    <p>
        というように計算すると、ある程度以上大きな \( N \) に対して \( \frac{1}{N^2} \) は非常に小さな値となり、この項は無視されることになり、それ以上 \( N \) を大きくしても近似は良くならない。
    </p>
    <p>
        これを防ぐには項の順序を変えて和を計算すればよい。小さい項から足していくようにすれば積み残しは防げる。具体的には
    </p>
    <p>
        \( \frac{1}{N^2} + \frac{1}{(N-1)^2} + \dots + \frac{1}{2^2} + 1 \)
    </p>

    <h1>Q4.２分法のアルゴリズムをかけ</h1>
    <h3>簡単な図は問題文にある</h3>
    <h2>6.1 2分法</h2>
    <p>
        2分法とは微積分学の中間値の定理を基礎としたものである。
    </p>
    <p>
        <strong>定理 6.1</strong>（中間値の定理）: 関数 \( g(x) \) が \( a \leq x \leq b \) に対して連続で \( g(a) \neq g(b) \) であれば、
        \( g(a) \) と \( g(b) \) の間の任意の値 \( \alpha \) に対して \( g(x_0) = \alpha \) となる \( a \leq x_0 \leq b \) が存在する。
    </p>
    <img src="else/6_1.jpg" alt="図6.1 2分法" />
    <p>図6.1 2分法</p>

    <p>2分法による非線形方程式の数値解のアルゴリズムは以下のようになる。</p>
    <p>\( f(x) = 0 \) となる \( x \) を求める。</p>

    <ol>
        <li> \( f(a) \) と \( f(b) \) の符号が反対になる \( a, b \) を見つける（ただし \( a < b \)）。すなわち「\( f(a) < 0 \) かつ \( f(b) > 0 \)」
            または「\( f(a) > 0 \) かつ \( f(b) < 0 \)」となることを確認する。\( f(a) f(b) < 0 \) であることを確認できる。 </li>
        <li> \( c_1 = a \) とする（\( c_1 \) は1ステップ前の解の候補）。</li>
        <li> \( c = \frac{a + b}{2} \) とする（\( c \) は \( a \) と \( b \) の中点、解の候補）。</li>
        <li> \( f(c) = 0 \) であれば、解 \( x = c \) として終了。</li>
        <li> \( f(c) \) と \( f(a) \) の符号が同じであれば \( a = c \) と置く。\( b \) はそのまま。</li>
        <li> \( f(c) \) と \( f(a) \) の符号が異なれば \( b = c \) と置く。\( a \) はそのまま。</li>
        <li> 終了条件を調べ、満足されていれば解 \( x = c \) として終了。満足されていなければ、\( c_1 \) を \( c \) として3に戻る。</li>
    </ol>

    <h3>終了条件</h3>
    <p>終了条件には以下のものを用いる。</p>
    <ul>
        <li> あらかじめ設定した繰り返し回数の上限を超えたら終了する。</li>
        <li> 十分小さい正の数 \( \epsilon \) に対して \( |c - c_1| < \epsilon \) となったら終了する。</li>
        <li> 十分小さい正の数 \( \epsilon \) に対して \( |f(c)| < \epsilon \) となったら終了する。</li>
    </ul>

    <h1>Q5.ニュートン法のアルゴリズムをかけ</h1>
    <h3>簡単な図は問題文にある。接戦の式 \( x_1 = x_0 - \frac{f(x_0)}{f'(x_0)} \) は問題文にある。</h3>
    <h2>6.2 ニュートン法</h2>
    <p>ニュートン法は、一般的に2分法より速く収束する。ニュートン法では \( f(x) \) は微分可能であると仮定する。</p>
    <img src="else/6_2.jpg" alt="図6.2 ニュートン法">
    <p>図6.2 ニュートン法</p>

    <ol>
        <li>解の候補の初期値を \( x_0 \) とする。</li>
        <li>\( x_0 \) から \( f(x_0) \), \( f'(x_0) \) を求め、\( x_1 = x_0 - \frac{f(x_0)}{f'(x_0)} \) とする。
            \( f'(x) \) は \( \frac{df(x)}{dx} \) のことである。</li>
        <li>\( |x_1 - x_0| < \epsilon \) であれば終了（\( x_1 \) は収束したので終了）、または \( |f(x_1)| < \delta \) であれば終了（\( f(x_1) = 0 \) とみなして終了）、
            また、繰り返し回数が設定した上限を超えたら終了。そうでなければ \( x_0 = x_1 \) として2に戻る。</li>
    </ol>

    <p>ニュートン法は一般には収束が速いという利点があるが、次のような場合には収束しないことがあるので注意が必要である。</p>
    <ul>
        <li>解の近くに変曲点がある場合</li>
        <li>解の近くに極小点や極大点がある場合</li>
    </ul>


    <h1>Q6.合成台形公式を求める</h1>
    <h2>4.3 台形公式</h2>
    <p>
        積分区間 \( [a, b] \) 間の関数 \( f(x) \) を両端点 \( (a, f(a)) \), \( (b, f(b)) \) を結ぶ直線で近似する：
    </p>
    <p>
        \( f(x) \approx \frac{f(b) - f(a)}{b - a} (x - a) + f(a) = \frac{f(b) - f(a)}{b - a} x + \frac{b f(a) - a f(b)}{b - a} \)
    </p>
    <p>これより、</p>
    <p>
        \( \int_a^b f(x) dx \approx \int_a^b \left( \frac{f(b) - f(a)}{b - a} x + \frac{b f(a) - a f(b)}{b - a} \right) dx \)
    </p>
    <p>
        \( = \frac{f(b) - f(a)}{b - a} \int_a^b x dx + \frac{b f(a) - a f(b)}{b - a} \int_a^b dx \)
    </p>
    <p>
        \( = \frac{f(b) - f(a)}{b - a} \left[ \frac{1}{2}x^2 \right]_a^b + \frac{b f(a) - a f(b)}{b - a} [x]_a^b \)
    </p>
    <p>
        \( = \frac{f(b) - f(a)}{b - a} \left( \frac{1}{2}(b^2 - a^2) \right) + \frac{b f(a) - a f(b)}{b - a} (b - a) \)
    </p>
    <p>
        \( = \frac{b - a}{2} (f(b) + f(a)) \) (4.3.1)
    </p>

    <h2>4.6.1 合成台形公式</h2>
    <p>
        積分区間 \( [a, b] \) が \( n \) 個の等分点で与えられている場合、\( n \) 個の分割領域にそれぞれ式 (4.3.1) の台形公式を用いる。\( h = \frac{b - a}{n} \) として、
        \( x_0 = a \), \( x_1 = a + h \), \( x_i = a + i h \), \( x_n = b \) とする。
    </p>
    <p>
        \( \int_a^b f(x) dx \approx \sum_{i=0}^{n-1} \frac{h}{2} (f(x_i) + f(x_{i+1})) \)
    </p>
    <p>
        \( = \frac{h}{2} \left( \sum_{i=0}^{n-1} f(x_i) + \sum_{i=0}^{n-1} f(x_{i+1}) \right) = \frac{h}{2} \left( \sum_{i=0}^{n-1} f(x_i) + \sum_{i=1}^{n} f(x_i) \right) \)
    </p>
    <p>
        \( = \frac{h}{2} \left( f(a) + 2 \sum_{i=1}^{n-1} f(x_i) + f(b) \right) \) (4.6.1)
    </p>

    <h1>Q7.合成台形公式で積分するアルゴリズム</h1>
    <ol>
        <li>区間の分割:
            区間 \( [a, b] \) を \( n \) 個の等間隔の部分区間に分割します。各区間の幅 \( h \) を次の式で計算します。
            \( h = \frac{b - a}{n} \) 分割点は次のように定義されます。\( x_0 = a \), \( x_1 = a + h \), ..., \( x_n = b \)
        </li>
        <li>端点の値の計算:
            端点での関数値 \( f(x_0) \) と \( f(x_n) \) を計算します。\( f(x_0) = f(a) \), \( f(x_n) = f(b) \)
        </li>
        <li>中間点の値の計算:
            内部の分割点 \( x_1 \), \( x_2 \), ..., \( x_{n-1} \) での関数値を計算し、次のように合計します。\( 2 \sum_{i=1}^{n-1} f(x_i) \)
        </li>
        <li>合成台形公式の適用:
            合成台形公式に基づいて積分値 \( I \) を計算します。\( I \approx \frac{h}{2} \left( f(a) + 2 \sum_{i=1}^{n-1} f(x_i) + f(b) \right) \)
        </li>
    </ol>

    <h3>アルゴリズムの疑似コード</h3>
    <pre><code>
        Input: f(x) (関数), a (積分の下限), b (積分の上限), n (分割数)
        Output: 積分値 I

        h = (b - a) / n
        I = f(a) + f(b)

        For i = 1 to n-1:
            I = I + 2 * f(a + i * h)

        I = h　/ 2 * I
        Return I
    </code></pre>
    <h1>Q8.オイラー (Euler) 法のアルゴリズム</h1>
    <p>微分方程式を数値的に解く一番簡単な方法は、以下に述べるオイラー法である。オイラー・コーシー (Euler-Cauchy) 法ともいう。この方法は解の精度や安定性に問題があるので、このままで用いられることは少ないが、様々な手法の基本となるので重要である。</p>
    
    <p>式 (8.1.3) の解 \( x(t) \) が微分可能な関数である場合には、テーラー展開により次式が成り立つ。</p>

    <p>
        \( x(t + h) = x(t) + h \frac{dx(t)}{dt} + \frac{h^2}{2} \frac{d^2 x(t)}{dt^2} + \dots \)
    </p>

    <p> \( h \) が小さいと仮定して、この式の右辺の第3項以下を無視すると、以下の近似式が得られる。</p>

    <p>
        \( x(t + h) \approx x(t) + h \frac{dx(t)}{dt} \)
    </p>

    <p>
        \( t = t_n \) とすると \( t_n + h = t_{n+1} \) なので、以下が得られる。
    </p>
    
    <p>
        \( x(t_{n+1}) \approx x(t_n) + h f(t_n, x(t_n)) \)
    </p>

    <p>これより \( x(t_n) \) の近似値 \( x_n \) を以下のように求めるのがオイラー法である。</p>

    <div style="border:1px solid black; padding:10px;">
        \( x_{n+1} = x_n + h f(t_n, x_n), \quad n = 0, 1, \dots, N \) 
    </div>
    <footer>
        Copyright <a href="else/suuchikeisan.html" style="text-decoration: none; color: inherit; cursor: text;">&copy</a> 2024 Uma. All right reserved.
    </footer>

</body>

</html>
